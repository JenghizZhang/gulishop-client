https://www.showdoc.com.cn/1489327909923000/7207032217058766

## day01

#### 01、脚手架创建项目
#### 02、认识项目目录及各个目录的作用
#### 03、vue的main.js基本编码

#### 04、eslint错误级别禁用   lintOnSave: false,

	原因：默认项目当中安装了eslint语法检查工具，而且默认检查的严格级别很高
	要开发阶段禁用eslint，否则会很多语法上的警告
	在vue.config.js写配置
	module.exports = {
  		lintOnSave: false,
	}

#### 05、jsconfig.json配置别名@提示     import XXX from '@/'
	@是一个别名，代表的是src的路径
	{
	"compilerOptions": {
		"baseUrl": "./",
		"paths": {
			"@/*": ["src/*"]
		}
	},
	"exclude": ["node_modules", "dist"]
	}

	配置完成跑起项目，没有报错各种都正常，证明项目准备没问题

	跑起来运行报错 （warning 找不到vue）  装的是3.0版本
	我们用的是2.6.11
	需要重新安装vue@2
	又找不到  vue-template-compiler
	安装 vue-template-compler

#### 06、git的基本操作和分支基本操作
	git基本操作
		先有本地代码
			创建本地库
			创建远程库
			关联本地和远程
			修改本地
			修改远程

		先有远程代码
			直接克隆


	git分支扩展
		分支创建和合并
			本地创建分支   git checkout -b dev
			本地推送新分支自动在远程库建立新分支  git push origin dev
			合并分支之前如果是多人协作先拉取一下远程master，以防止别人已经做了更改
			本地切换到master 然后再合并分支  git merge dev 
			合并之后再次推送到远程master
		分支删除
			项目开发完成可以删除分支		  
			git push origin --delete dev  删除远程分支
			git branch -d dev  删除本地分支 



#### 07、观察页面确定页面主体框架
	所有的功能页面都是 上中下结构    上和下是不变化的，只有中间在变化
	切换页面的时候，页面不刷新，证明切换过程请求是ajax请求
	这个是单页面应用，中间部分是路由组件切换   	

#### 08、定义页面主体组件组装，切换路径可以组件跳转（非路由组件和路由组件）
	Header和Footer是固定的所以是非路由组件
		定义：定义在components
		注册：注册在App
		使用：在App中写标签
	Home  Search  Login  Register 都是点击才会出现所以是路由组件并且是一级的（可能内部还有二级）
		定义：定义在Pages中
		注册：
			路由器相关配置
				安装路由 yarn add vue-router
				引入并声明使用路由插件
				向外暴露一个路由器对象
				在main.js中注册到Vue的配置对象当中
			注册路由组件（配置路由）
		使用：router-link router-view $router.push或replace

			  

#### 09、把Header和Footer的模板进行替换显示
	引入html到vue组件 template
	引入less到vue组件 style   解决loader   只需要安装less 和 less-loader就可以了
	引入图片
	修改为router-link router-view，修改a标签和按钮编程式导航
	添加重定向路由

#### 10、配置路由在对应点击切换路由组件的位置，替换路由链接	
	声明式导航和编程式导航

#### 11、登录注册不需要Footer,通过路由meta配置解决
	从route当中可以获取到path判断可以解决但是麻烦
	可以通过$route.meta的配置来对是否展示其他组件来进行控制

#### 12、路由传参相关
    路由路径的写法
    	1. 字符串写法 ''或``
    	2. 对象写法 {name,query,params}

	1)跳转路由的2种基本方式
        	声明式: <router-link to="">
        	编程式: this.$router.push()/replace()

	2)跳转路由携带参数的2种方式
        	params参数 属于路径的一部分，需要占位
        	query参数  不属于路径的一部分不需要占位
			无论是params还是query参数，最终匹配完成都会解析到当前的路由对象当中，可以通过this.$route来获取params和query
			可以在路径后拼接    2种  （+，模板字符串）
			也可以使用对象写法  

	3)面试问题1: 
		描述: 编程式路由跳转到当前路由(参数不变), 多次执行会抛出NavigationDuplicated的警告错误
		      声明式路由跳转内部已经处理
		原因：vue-router3.1.0之后, 引入了promise的语法
		     如果没有通过参数指定成功或者失败回调函数就返回一个promise且内部会判断如果要跳转的路径和参数都没有变化,会抛出一个失败的promise

		解决: 1：在跳转时指定成功或失败的回调函数, 或者catch处理错误
		      2: 修改Vue原型上的push和replace方法 (优秀)

    4)面试问题2: 如何指定params参数可传可不传?
    	path: '/search/:keyword?'

	5)面试问题3: 指定params参数时可不可以用path和params配置的组合?（对象写法）
		不可以用path和params配置的组合, 
		只能用name和params配置的组合
		query配置可以与path或name进行组合使用

	6)面试问题4: 如果指定name与params配置, 但params中数据是一个"", 无法跳转，路径会出问题
		前提是路由params参数要可传可不传
    		解决1: 不指定params
		解决2: 指定params参数值为undefined

	7)面试问题5: 路由组件能不能传递props数据?
    		可以: 可以将query或且params参数映射/转换成props传递给路由组件对象
		实现: props: (route)=>({keyword1:route.params.keyword, keyword2: route.query.keyword })



## day02

#### 13、先来搞Home,Home的子组件静态页面实现
	费时费力  但是莫急莫慌
	Home的静态页面就有了，接下来要去实现动态数据
	1、TypeNav  
	2、图片路径

#### 14、postman测试后台api接口，保存请求信息以便后期使用（参考接口文档）
	postman的基本使用方法

#### 15、前后台交互模块ajax模块，对axios的二次封装
	获取数据离不开ajax，所以先把ajax工具搞定

		配置基础路径和超时限制

		添加进度条信息  nprogress

		返回的响应不再需要从data属性当中拿数据，而是响应就是我们要的数据

		统一处理请求错误, 具体请求也可以选择处理或不处理
	
#### 16、所有接口的请求函数模块，我们定义一个index.js去写
	以后请求什么数据直接导入去调函数就可以
	先写请求三级分类列表数据
	测试ajax请求是否能够拿到数据

#### 17、测试ajax请求机解决跨域问题
	
	返回404需要解决跨域
	配置代理服务器解决跨域问题

#### 18、可以拿到数据，但是我们得去管理我们的数据，使用vuex
	每个vuex模块都能包含 state  mutations actions getters
	多模块化  画图分析
	总的state结构是什么
	mapState的写法分析  之前的state就是总的state  现在state里面包含了子模块对象
	state结构要注意
	state:{
		home:{
		},
		user:{
		}
	}

#### 19、获取到数据后显示三级分类列表
	分析数据结构：在模板上展示数据v-for

	鼠标悬停在链接上变色，需要修改一下公共样式
	悬停在分类上背景色需要变化，修改分类组件的样式
	三级分类列表宽度比较小，右边的缝隙比较大

## day03

#### 20、事件控制23级的显示和隐藏
	原来的是使用css去做的，咱们不用
	添加移入和移出事件（关键是数据的设计）
		1. 移入哪一个把哪一个的index，传到回调函数，然后把currentIndex = index
		2. 上面使用类的对象写法：item_on : currentIndex == index
		3. 而移出事件我们需要移出全部分类的时候才会消失，因此移出事件我们需要添加在外部一个div上
		4. 设计一个数据currentIndex一开始是-1
		5. 移入的时候，让currentIndex=index
		<div 
            class="item" 
            :class="{item_on:currentIndex===index}" 
            @mouseenter="currentIndex=index" 
			也要写移除
            v-for="(c1,index) in categoryList" 
            :key="c1.categoryId"
        >

#### 21、演示快速触发事件卡顿现象

#### 22、函数的防抖和节流讲解
	100秒触发100次
	正常：事件触发非常频繁，而且每一次的触发，回调函数都要去执行
	节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发
	防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会，也就是说如果连续快速的触发  只会执行一次

#### 23、优化快速触发typeNav鼠标移入和移出事件，节流lodash的throttle节流操作
	将移入事件的回调进行节流操作

#### 24、按需引入lodash减少打包体积
	引入的时候不要去引入整个lodash
	引入lodash/throttle

#### 25、解决使用lodash节流后，快速移出后，可能还会显示某个子项
	{ 'trailing': fasle}的作用    是否在结束延迟之后调用

#### 26、点击某个类别（无论几级）跳转到搜索页面
	先用声明式导航替换原来的a
	需要把类别的id和类别的名字通过query参数传递
	
#### 27、使用编程式路由导航优化声明式导航组件对象过多造成的卡顿
	声明式导航本质上是组件对象，组件对象过多，会造成效率很慢  所以会很卡
	
#### 28、利用事件委派提高处理事件的效率
	每个项都添加事件，事件的回调函数很多，效率也不好
	在共同的父级元素添加事件监听
		问题：怎么知道点击的是不是a标签
		问题：怎么知道点击的是一级还是二级还是三级
		问题：参数怎么携带，要携带携带哪些个的参数

#### 29、利用自定义属性携带动态数据
	标签的data-开头的属性，叫做自定义属性
	通过我们的标签对象.dataset

### 跳转搜索页后

#### 30、搜索页的typeNav一级列表隐藏
	首先这个组件被多个页面公用
	在mounted的时候可以判断路由是不是home如果不是把isShow改为false,  只是初始显示组件的时候隐藏一级分类
	移入外部div的时候，一级分类要显示
	再次考虑外部盒子移入和移出  首页的移入移出，不会隐藏，但是其余的会移出隐藏
	点击搜索类别跳转到当前搜索页面也要把一级类别隐藏


#### 31、显示和隐藏一级列表的过渡效果添加
	首先谁要加过渡就看谁在隐藏和显示
	需要放在transition标签内部，name需要起名字
	参考官方给的过渡图
	移入的时候是有过渡的
	移出的时候立马隐藏的
	注意：高度也是变化的

#### 32、优化typeNav数据ajax请求次数，改变请求的位置
	之前我们是在typeNav组件内部dispatch去发送ajax请求，这样的话
	因为typeNav是被多个页面公用的，所以每次切换到一个页面，这个组件都会重新创建  mounted都会执行
	因此有几个页面公用了这个typeNav就会执行几次ajax请求还不包含切换
	所以我们放到App里面就只用执行一次，因为数据一样，没必要多次请求

#### 33、合并分类的query参数和搜索关键字的params参数
	找到对应组件
	点击search按钮的时候，去看看有没有query参数
	点击类别选项的时候，去看看有没有params参数
	注意：我们点击搜索的时候关键字使用的是params参数
	      点击类别选项的时候我们的参数使用的是query参数

## day04

### 接下来我们就要做首页的ListContainer和Floor组件

#### 34、设计json数据的结构和值
	banner.json
	floor.json
	
#### 35、使用mockjs来模拟数据接口（其实和ajax差不多，mock其实就是给我们的json数据指定一个url路径去做请求）
	准备json数据
	使用mockjs来模拟提供接口地址
	在main中引入mockServer.js
	在ajax当中修改Ajax中的baseUrl 为 /mock  变为一个新的文件 mockAjax

	mock会拦截我们的ajax请求，不会真正去发送请求。（发送请求是往本地发的，没有往后端发，请求的数据也是本地的）
	
#### 36、mock数据的随机语法
	看文档

#### 37、mock数据的vuex编码
	和categoryList的获取几乎一致，把mock接口当真正接口对待就好了

#### 38、实现页面轮播
	swiper的用法参考官方网站
	安装 引入js和css
	swiper必须在页面的数据结构显示完成后创建才会生效

#### 39、解决swiper影响多个页面的bug
	通过选择器可以指定哪个地方需要，但是不好
	通过ref最好

#### 40、swiper创建的时间应该是在页面列表创建之后才会有效果
	静态页面是没问题的
	静态页面不需要等待数据，因此monted完全可以去创建swiper

	现在我们的数据是动态的，monted内部去创建，数据还没更新到界面上，因此无效
	可以使用延迟定时器去创建 但是不好

#### 41、使用watch + nextTick  去解决比较好	
	Vue.nextTick 和 vm.$nextTick 效果一样
	nextTick是在最近的一次更新dom之后会立即调用传入nextTick的回调函数

#### 42、动态显示Floor组件
	数据要对应起来

#### 43、Floor当中的轮播没效果？
	它是根据数据循环创建组件对象的，外部的floor创建的时候
	所以数据肯定是已经获取到了，所以我们在mounted内部去创建swiper

#### 44、定义可复用的轮播组件
	banner是在watch当中去创建swiper 因为组件创建的时候数据不一定更新
	floor是在mounted当中去创建swiper，因为内部组件创建的时候，数据已经存在了

#### 45、查看数据的时候应该怎么去查看
	看组件没有数据  接着看vuex没有数据   然后看network请求状态

## day05

#### 46、实现search与searchSelector静态组件
	searchSelector是search组件的一个子组件

#### 47、search接口测试和编写请求函数 （参数按照文档的给定）
	参考接口文档去做

#### 48、search模块vuex编码
	编码和前面的类似  每写一步就测试一步

#### 49、搜索条件参数的理解和初始data收集参数准备
	传递参数对象，至少得传递一个没有属性的对象
	搜索参数是怎么组成的，参考文档
	在Search组件当中data设置初始参数的对象（因为不管怎么样搜索必须要一个初始的参数，没有就没办法）

#### 50、search组件动态显示（先不搜索，获取数据去动态展示）
	data设置初始准备参数已经设置好了
	在mounted内部可以发送请求
	在computed内部获取我们的数据
	search页面商品动态数据展示
	searchSelector组件内部数据动态展示

#### 51、根据分类和关键字进行搜索，解决在search组件内部再进行搜索的bug
	data当中需要定义一个对象，代表是所有的搜索参数的对象，称为初始化搜索参数
		一部分是空串，是搜索时候要更新的
		一部分是给定的，默认给后台传递的数据
	真正到了搜索页面我们都要去解析拿到相关的参数  修改我们的搜索参数
		beforeMount 去同步更新data数据
		mounted     去异步发送请求
	在搜索页重新输入关键字或者点击类别不会再发送请求，因为mounted只会执行一次，需要监视路由变化

#### 52、动态显示和删除选中的搜索条件发送请求
	判断参数内部是否存在categoryName  存在就显示
	判断参数内部是否存在keyword 存在就显示
	点击事件，如果删除就把参数对应的数据清除，顺便发送新的请求

#### 53、解决删除选中的搜索条件后路径不变的bug
	上面删除发送请求我们的请求路径还是不变
	我们需要手动去push跳转到去除对应参数的新路由

#### 54、解决删除关键字后，输入框没有更新输入的bug
	组件间通信，删除关键字后通知header组件，全局事件总线的使用
	
#### 55、根据品牌搜索（设置和删除）
	给对应品牌添加点击事件
	点击的时候需要给父组件search传递品牌的参数  参数结构参考接口文档
	子向父通信

#### 56、根据属性搜索（设置和删除）
	给对应的属性值添加点击事件
	点击的时候需要给父组件search传递属性值参数  参数结构参考接口文档
	使用组件间通信	
	点击删除的时候从参数内部把对应的属性值参数删除，数组的方法

## day06

#### 57、解决在搜索页多次跳转后不能直接返回home的问题
	查看之前书写的所有跳转路由
	如果是搜索页往搜索页去跳转使用replace
	如果是home页往搜索页去跳转使用push

#### 58、getters的用法简化searchSelector中数据的获取  mapGetters使用

#### 59、响应式对象数据属性的添加和删除
	对象当中的属性数据更改会导致页面更改，响应式数据
	
	添加：
		错的：如果对象当中没有对应的属性数据： 直接添加一个属性，这个属性不是响应式的
			因为vue只是在开始对对象当中的所有属性添加getter和setter，后期直接添加的没有
		
		对的：我们需要使用Vue.set  this.$set方法  这样的添加属性就是响应式的   必须对响应式对象添加属性

	删除：
		错的： 直接delete删除对象当中的属性，不会导致页面更改
			因为响应式属性只是在检测属性值的改变而不是检测属性的删除
 
		对的：我们需要使用Vue.delete this.$delete方法  除了删除，还添加了更新界面的操作
	
#### 60、排序数据的分析4种情况   
	order: '1:desc' 排序是根据此数据来排序的 orderFlag:orderType
	冒号前面代表的是排序标志： 1标识综合排序 2标识价格排序
	冒号后面代表队是排序类型： asc代表的是升序 desc代表的是降序

#### 61、动态确定排序项和排序方式
	1. 哪个排序项选中并且有背景色（根据数据中的orderFlag决定active的类名）
	2. 哪个排序选项有图标  
		图标是向上还是向下（根据数据中的orderType决定） asc和desc
		何时出现 和背景色一样，谁有背景色谁就有图标
	3. 点击切换排序包含排序项和排序方式
		点击当前排序项         切换排序方式
		点击不是当前排序项     切换排序项指定默认排序方式
		点击排序项的时候传递自身的排序项标识数据  一个方法搞定

#### 62、模板内部的表达式优化计算属性值

#### 63、分页组件

#### 64、自定义通用的分页组件

##### 实现静态组件
	1、去课件当中获取到分页的静态组件
	2、注册组件并渲染静态组件

##### 实现动态组件
	数据：
      	1. 记录当前页面的页码
      	2. 展示总条数
      	3. 展示一共有多少页
      	4. 展示连续页数
	功能：
      	1. 翻页的功能

	3、动态组件的逻辑和功能
      	3-1：分页组件所需要的从父组件传递的数据是那些（1、当前页码  2、每页数量  3、总数  4、连续页数）  
      	3-2：分页内部需要计算的数据：总页数  连续页码的起始和结束
      	3-3：在分页当中开始去计算逻辑

##### 实现静态组件（模板结构样式）
	参考文档去获取

##### 设计数据
	外部接受的
      	当前页码
      	每页数量
      	总数
      	连续页码数量   一般都是奇数个

	自己内部计算的
      	总页数
      	连续页码的起始和结束

      	1、先判断连续页码数是不是比最大的页码还要大，如果是那么start=1  end就是最大页码

      	2、如果连续页码数比最大页码小
      		正常情况：
			  	我们让start  =   当前页码 - 连续页码/2 取整
      			end   =    当前页码 + 连续页码/2 取整
      		非正常情况：
      			如果start 求出来比1还小  那么start修正为1 end为continueNo
      			如果end   求出来比最大页码还大 同样end修正为最大页码  start为totalPageNo-continueNo+1

##### 动态显示页码
	每一个button都要考虑什么时候显示  还有什么时候是选中状态 

	什么时候显示和禁止操作
		上一页：如果当前页等于1 禁止操作 disabled
		第1页： 当start大于1才会显示  
		。。。: 当start大于2
		中间的连续页： v-for遍历数字  然后判断 如果大于等于start才会显示   
		。。。: 当当前页小于总页数 - 1才会显示
		最后一页：当end小于最后一页，才会显示 
		下一页：如果当前页等于最后一页 禁止操作

	什么时候选中状态
		如果当前页和目前遍历的这个页码是一样的，那么就添加active类

	点击页码修改当前页码值
	每个都要考虑  第一页  上一页  中间的连续页  最后一页 下一页

	更新页码父组件要去发请求
	把自身改变页码传给父组件修改参数重新发送请求

	父组件搜索条件更新，需要当前页码修改为1
	分页也就从1开始了，因为它是父的页码传递过去的

## day07
				
#### 65、详情组件
	一个一级路由组件，使用已经写好的
	商品列表页点击商品会跳转到详情页 需要携带params参数  商品id
	配置路由
	跳转过去后可能滚动条位置不对（参考router官网滚动配置）  scrollBehaviors
		注意是给路由器配置的选项

#### 66、浏览器发送ajax请求，携带属性值如果是undefined不会发送，但是如果是“”是要发送的
	如何优化，在发送请求前把空串的属性干掉，但是不能影响原来的内部属性

#### 67、Detail组件动态显示
	ajax请求函数
	vuex管理	
	获取数据
	展示数据
		商品数据  
		放大镜大图和小图拿的是同一套  全部让父组件传递过去就好了（要处理假报错的问题）

	交互
		图片列表的点击切换样式
		图片列表点击大图要跟着切换  组件通信index下标
		
		放大镜
			鼠标动  
			遮罩动
				求遮罩的位置
				设置遮罩的位置
			大图动
				大图反向移动遮罩的位置2倍  


		商品售卖属性的点击切换（排它）
			
#### 68、添加购物车需要发送请求，跳转到添加购物车成功
	如何知道成功还是失败    
		1、分发的时候传过去一个回调函数作为参数

		2、使用promise 
			async和await

			async函数返回值是一个promise   而且这个promise的状态结果  由当前函数return的返回值决定
			promise状态返回：
				函数返回undefined       成功
				函数正常返回值          成功
				函数返回 成功的promise  成功
		
		函数返回 失败的promise  失败
				函数抛出错误            失败




		
	成功之后跳转路由到添加成功组件    需要带一个query参数  skuNum 

	
	添加成功组件需要用到商品信息所以跳转路由要保存商品信息  保存信息的多种方式（localStorage和sessionStorage）
		
				
	动态显示添加成功页面数据

## day08
#### 69、购物车shopCart静态组件
	调整css让各个项目对齐    删除第三项   15  35  10 17 10 13
	
#### 70、购物车组件动态展示
	请求数据
		展示：
			数据是要去请求接口的
			请求购物车列表数据
			写了接口请求发送也获取不到数据，因为没有身份标识
				用户的临时id（userTempId）
				用户没有登录前的身份标识
				如果没有登录，用户需要查询数据，需要带上这个身份标识
					它是一个随机的唯一的字符串标识    uuid

				创建和保存
					浏览器端创建，每次请求都携带上，尽量不要修改
					应用一打开就创建保存在localStorage
					在state当中也去保存一份，这样的话为了更快

				使用
					使用请求拦截器每个请求都带上
						
				做法：
					书写工具函数去实现创建和保存uuid值
					在state当中去调用这个函数
					在ajax发送请求时候，所有请求头当中携带这个标识

			展示购物车数据（需要计算）








		交互：
			更新购物车数量数据

			更新购物车选中状态数据



Promise.all()  处理多个promise的数组，如果都成功那么返回的promise才成功，结果是每个成功的promise的结果组成的数组
				      如果失败，返回的第一个失败的promise的reason






			删除购物车数据
			

							

购物车完成后该去创建订单了，此时登录注册就必须要搞定，因为只有登录的用户才有创建订单的可能


## day 09			
	
71、	注册：
		静态组件
		api
		store
		收集数据发送请求
		请求成功代表注册成功，那么就跳转到登录页	
	
		
72、	登录：
		
		静态组件
		api
		store
		收集数据发送请求
		请求成功后需要把用户信息保存在localStorage用于自动登录
		state的用户信息也要修改，
		state的用户信息读取先从localStorage里面去读，没有就是{},通过登录去修改
		以后每次发请求都要携带这个用户信息的token
		修改头部的用户状态信息


	自动登录：  不需要请求 就是把用户信息存储完了再次打开取出展示
		
		
73、	退出登录：
			
		请求成功在store中把用户信息的数据清除（state和localStorage里面都要清除）



74、	携带token去进行后续操作

	userTempId和token的区别

		userTempId  未登录状态下的用户身份识别标识

		token       登录状态下的用户身份识别标识 

		两个都存在的话，后台会合并临时id对应的信息到token对应的信息上


  
登录注册完成再去做订单交易的流程



点击购物车结算会去到订单交易trade页面=》 这个页面在准备创建订单的信息 


点击订单交易页面提交订单=》  真正的把创建订单的信息提交发送请求，真正的去创建订单，返回的是订单编号
			    也就是我们必须在交易页面提交订单的时候发送请求去创建订单获取订单编号
			    没有订单编号，直接跳转到支付页面没意义

会去到订单支付页面 =》  前面交易页面提交订单拿到了订单编号会跳过来     
点击立即支付会弹出二维码


 
75、	

	点击购物车结算会去到订单交易页面   去到之后需要发请求获取创建订单所需要的的交易信息，完成页面展示

	静态组件显示
	api
	store
	组件发请求
	获取数据
	组件展示数据
	完成交互





76、   点击创建订单页面提交订单    需要先发请求 提交订单信息   成功返回订单编号   把订单编号携带跳转路由去到订单支付页面

	在订单交易信息页面发送提交订单请求
	如果成功 路由跳转到支付页面，需要把提交订单成功的订单编号携带过去



77、   订单支付页面也需要支付信息   需要在订单支付页面根据订单编号发送请求获取支付信息，完成页面展示
	需要发请求根据订单编号，查询订单数据，展示页面



78、  点击订单支付页面立即支付会出现一个支付二维码
	订单数据当中包含了一个codeUrl，是用来让我们生成二维码用的

	npm install --save qrcode   但是github去搜索的时候，搜索node-qrcode  用于把返回的图片地址生成二维码

	使用element-ui去做弹出显示  参考官网进行局部配置和打包






	支付流程：
		1、生成了二维码
		2、messageBox展示了二维码
		3、刚展示完二维码：立马就需要发请求（这个请求要连续的去发） 隔2秒发一次 ，去查询支付状态是否支付完成
		4、后台会在发请求后返回支付状态码  支付状态码如果是205代表还在支付中，如果是200代表支付成功
		5、根据返回的支付状态码去决定后续操作
				1》如果在查询回来是200的时候，我们要自动跳转到支付成功页面，关闭messageBox,
				2》把这个状态码还要保存在data当中，用来去作为用户点击已成功支付按钮的判断依据

		6、去单独的处理点击我已成功支付或者支付遇到问题按钮的逻辑
				1》点击我已成功支付，那么要根据data当中存储的状态码判断是否真的支付完成，
					如果完成跳转到支付成功页面，关闭messageBox,
					如果没有完成，停在当前页面并提示,不关闭messageBox,

				2》点击支付遇到问题，那么我们要提示用户找谁处理，停止往后台发请求，关闭messageBox
			




	点击立即支付
		1、我们需要根据codeUrl 使用qrcode生成要显示的微信二维码url
		2、使用element-ui的this.$alert 弹出消息框显示二维码图片，使用需要显示html的消息框
		3、弹出消息框的时候，我们需要循环定时器去查询支付状态
		4、如果支付成功，那么把支付成功的状态码保存在data当中，并且清除定时器，自动跳转到支付成功页面
		5、如果点击我已经支付成功，那么需要判断状态码是不是成功，如果成功那就关闭提示框，不成功就提示不关闭
			（需要放在messageBox的beforeClose回调当中去，判断 然后手动关闭）
		6、如果点击支付失败，那么需要提示信息 清除定时器  关闭提示框 关闭也要去手动关闭
			（需要放在messageBox的beforeClose回调当中去，判断 然后手动关闭）
		7、支付成功才能到支付成功页面，那么我们都要去花钱，所以把支付功能简化，直接点击就能跳


	
79、支付成功后我们可以跳转到支付成功页面
	静态组件


80、在支付成功页面我们可以选择继续购物，去到首页  也可以查看订单，去到用户中心



81、用户中心组件及子路由组件
	子路由组件拆分   我的订单和团购订单
	请求数据  在我的订单组件里面存储数据就好
	展示我的订单页面
	分页器的使用 和前面一样  把该传递的参数要传递过去  子组件点击修改页面，要通知父组件修改




82、路由守卫的理解（参考官网去写代码）
	有特定条件才能去到相应的页面的功能  
	拦截路由，查看是否满足条件，满足的放行，不满足的处理


83、必须登录后才能访问的多个界面使用全局守卫
	（交易相关、支付相关、用户中心相关） 自动跳转前面想而没到的页面
	

84、只有没登录才能看到登录的界面 路由独享守卫和组件守卫


85、只有携带了skuNum和sessionStorage内部有skuInfo数据  才能看到添加购物车成功的界面


86、只有从购物车界面才能跳转到交易页面（创建订单）


87、只有从交易页面（创建订单）页面才能跳转到支付页面


88、只有从支付页面才能跳转到支付成功页面




89、图片懒加载
	还没有加载得到目标图片时, 先显示loading图片
	在<img>进入可视范围才加载请求目标图片
	参考文档去写




90、路由懒加载  
	

	调用import函数把一次性打包的所有路由组件分开去打包加载 

	const Home = () => import('@/views/Home') 


	打包会打包成一个单独的文件

	访问哪一个再去加载哪一个

	(1）	当打包构建应用时，JS包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，
		然后当路由被访问的时候才加载对应组件，这样就更加高效了

	(2)	本质就是Vue 的异步组件在路由组件上的应用

	(3)	需要使用动态import语法, 也就是import()函数

	(4)	import('模块路径'): webpack会对被引入的模块单独打包一个小文件

	(5)     当第一次访问某个路径对应的组件时，此时才会调用import函数去加载对应的js打包文件



91、验证规则插件的使用vee-validate  使用2版本  最新3版本




结算到支付的流程
1、购物车页面点击了结算直接跳转到订单交易页面

2、跳转到订单交易页面需要发请求获取订单交易信息
	订单的交易信息 1、为了获取创建订单所用的交易编号
		       2、为了让用户去确定最终的交易信息

3、点击订单交易页面下边的提交订单
	点击这个按钮不是立马就跳转到支付页面
	先要根据交易信息和交易编号，发请求真正的去创建订单，返回订单编号之后再去跳转到支付页面，带上订单编号




































	




 
	
	
	


